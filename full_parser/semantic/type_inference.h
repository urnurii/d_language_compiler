#ifndef TYPE_INFERENCE_H
#define TYPE_INFERENCE_H

#include "semantic_types.h"

/* ============================================================================
   ВЫВОД ТИПОВ И ПРОВЕРКА СОВМЕСТИМОСТИ ТИПОВ
   ============================================================================ */

/* ВЫВОД ТИПОВ ВЫРАЖЕНИЙ */

/* Определить тип выражения
   Рекурсивно вычисляет тип на основе структуры выражения:
   - Константы: тип литерала
   - Переменные: тип из таблицы символов
   - Бинарные операции: результирующий тип операции
   - Вызовы функций: возвращаемый тип функции
   - Доступ к полям: тип поля класса
   - Массивы: базовый тип элемента (без размерности)
   
   expr: выражение для анализа
   ctx: контекст анализа (для поиска типов переменных/функций)
   
   Возвращает: новый NType объект с вычисленным типом или NULL при ошибке
   Использует: ReportError если не удаётся определить тип */
NType* InferExpressionType(NExpr *expr, SemanticContext *ctx);

/* Определить тип для константы (литерала)
   INT -> TYPE_INT
   FLOAT -> TYPE_FLOAT
   STRING -> TYPE_STRING
   CHAR -> TYPE_CHAR
   BOOL -> TYPE_BOOL
   NULL -> TYPE_CLASS (специальный случай)
   NAN -> TYPE_FLOAT
   
   Возвращает: NType с соответствующим базовым типом */
NType* InferLiteralType(NExpr *expr);

/* Определить результирующий тип бинарной операции
   Для арифметических операций (+, -, *, /):
   - int op int -> int
   - float op float -> float
   - int op float -> float (automatic promotion)
   
   Для сравнений и логических операций (==, !=, <, >, &&, ||):
   - результат всегда bool
   
   Для присваивания (=, +=, -=, *=, /=):
   - результат тип левого операнда
   
   Возвращает: результирующий тип или NULL если операция недопустима */
NType* InferBinaryOperationType(OpType op, NType *left_type, NType *right_type);

/* Определить тип для унарной операции
   Для унарного минуса и плюса (-expr, +expr):
   - -int -> int
   - -float -> float
   
   Для логического НЕ (!expr):
   - !любой_тип -> bool
   
   Возвращает: результирующий тип или NULL если операция недопустима */
NType* InferUnaryOperationType(OpType op, NType *operand_type);

/* ПРОВЕРКА СОВМЕСТИМОСТИ ТИПОВ */

/* Проверить, совместимы ли два типа в операции
   Используется для проверки:
   - Операндов бинарной операции
   - Аргументов функции
   - Присваивания
   
   Типы совместимы если:
   - Это один и тот же тип
   - Возможно автоматическое преобразование (int -> float)
   - Для объектов: типы совпадают или есть наследование
   
   type1, type2: сравниваемые типы
   strict: 1 для строгой проверки (только совпадение), 0 для допуска преобразований
   
   Возвращает: 1 если совместимы, 0 если нет */
int AreTypesCompatible(NType *type1, NType *type2, int strict);

/* Проверить, может ли type2 быть присвоен type1
   Правила присваивания:
   - Одинаковые типы: да
   - int = float: нет (потеря данных)
   - float = int: да (автоматическое преобразование)
   - Наследование: производный класс может присваиваться базовому
   
   Возвращает: 1 если можно, 0 если нет */
int CanAssign(NType *target_type, NType *source_type);

/* Проверить, совместимы ли типы параметра и аргумента
   Учитывает особенности языка D:
   - ref параметры требуют точного совпадения
   - Обычные параметры допускают преобразования
   
   param_type: тип параметра функции
   arg_type: тип аргумента
   is_ref: является ли параметр ref параметром
   
   Возвращает: 1 если совместимы, 0 если нет */
int IsArgumentCompatibleWithParameter(NType *param_type, NType *arg_type, int is_ref);

/* СПЕЦИАЛЬНЫЕ ПРОВЕРКИ */

/* Проверить, является ли тип числовым (может участвовать в арифметике)
   Числовые типы: int, float, double, real, char (в некоторых контекстах)
   
   Возвращает: 1 если числовой, 0 если нет */
int IsNumericType(NType *type);

/* Проверить, является ли тип целым (int, char)
   
   Возвращает: 1 если целый, 0 если нет */
int IsIntegralType(NType *type);

/* Проверить, является ли тип с плавающей точкой (float, double, real)
   
   Возвращает: 1 если float, 0 если нет */
int IsFloatingPointType(NType *type);

/* Проверить, является ли тип булевым
   
   Возвращает: 1 если bool, 0 если нет */
int IsBooleanType(NType *type);

/* Проверить, может ли тип использоваться как индекс массива
   Индекс должен быть целым числом (int, char)
   
   Возвращает: 1 если может, 0 если нет */
int CanBeArrayIndex(NType *type);

/* Проверить, может ли тип использоваться как условие (if, while, для логических операций)
   Условие должно быть bool или числовым типом
   
   Возвращает: 1 если может, 0 если нет */
int CanBeCondition(NType *type);

/* СОЗДАНИЕ И КОПИРОВАНИЕ ТИПОВ */

/* Создать копию типа (глубокая копия)
   Нужна для сохранения типов в структурах узлов AST
   
   Возвращает: новый NType с копией информации или NULL при ошибке */
NType* CopyType(NType *type, SemanticContext *ctx);
NType* CopyTypeNoContext(NType *type);

/* Сравнить два типа на полное совпадение
   Учитывает: базовый тип, размерность массива, имя класса
   
   Возвращает: 1 если идентичны, 0 если нет */
int TypesEqual(NType *type1, NType *type2);

/* Преобразовать тип к строке для вывода ошибок
   Например: "int", "string", "float[]", "MyClass"
   
   Возвращает: строка (не должна быть освобождена пользователем) */
const char* TypeToString(NType *type);

#endif /* TYPE_INFERENCE_H */
